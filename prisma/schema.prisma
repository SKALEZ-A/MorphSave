// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model User {
  id                String   @id @default(cuid())
  email             String   @unique
  username          String   @unique
  firstName         String?
  lastName          String?
  profileImage      String?
  bio               String?
  dateOfBirth       DateTime?
  phoneNumber       String?
  country           String?
  timezone          String   @default("UTC")
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  lastLoginAt       DateTime?
  isActive          Boolean  @default(true)
  isVerified        Boolean  @default(false)
  
  // Authentication
  passwordHash      String?
  emailVerifiedAt   DateTime?
  phoneVerifiedAt   DateTime?
  twoFactorEnabled  Boolean  @default(false)
  twoFactorSecret   String?
  recoveryCode      String?
  
  // Wallet & Blockchain
  walletAddress     String?  @unique
  privateKeyEncrypted String?
  walletProvider    WalletProvider @default(METAMASK)
  
  // Gamification
  level             Int      @default(1)
  totalPoints       Int      @default(0)
  currentStreak     Int      @default(0)
  longestStreak     Int      @default(0)
  lastActivityDate  DateTime?
  
  // Financial
  totalSaved        Float    @default(0)
  totalYieldEarned  Float    @default(0)
  savingsGoal       Float?
  monthlyTarget     Float?
  riskTolerance     RiskTolerance @default(MEDIUM)
  
  // Settings
  roundUpEnabled    Boolean  @default(true)
  roundUpAmount     Float    @default(1.0)
  notificationsEnabled Boolean @default(true)
  autoInvestEnabled Boolean  @default(true)
  autoCompoundEnabled Boolean @default(true)
  privacyLevel      PrivacyLevel @default(FRIENDS)
  
  // Preferences
  currency          String   @default("USD")
  language          String   @default("en")
  theme             String   @default("light")
  
  // Relations
  savingsTransactions SavingsTransaction[]
  achievements       UserAchievement[]
  challengesCreated  Challenge[] @relation("ChallengeCreator")
  challengeParticipations ChallengeParticipant[]
  friendships        Friendship[] @relation("UserFriendships")
  friendOf           Friendship[] @relation("FriendOf")
  notifications      Notification[]
  sessions           UserSession[]
  bankAccounts       BankAccount[]
  
  @@map("users")
}

model UserSession {
  id          String   @id @default(cuid())
  userId      String
  sessionToken String  @unique
  deviceInfo  String?
  ipAddress   String?
  userAgent   String?
  isActive    Boolean  @default(true)
  expiresAt   DateTime
  createdAt   DateTime @default(now())
  lastUsedAt  DateTime @default(now())
  
  // Relations
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("user_sessions")
}

model Session {
  id        String   @id
  userId    String
  type      SessionType @default(GENERAL)
  expiresAt DateTime
  createdAt DateTime @default(now())
  
  @@index([userId, type])
  @@index([expiresAt])
  @@map("sessions")
}

model TransactionHistory {
  id              String   @id @default(cuid())
  hash            String   @unique
  fromAddress     String
  toAddress       String
  value           String
  gasUsed         String
  gasPrice        String
  blockNumber     Int
  timestamp       DateTime
  status          String
  type            String
  description     String?
  contractAddress String?
  methodName      String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  // Relations
  tokenTransfers  TokenTransfer[]
  
  @@index([fromAddress])
  @@index([toAddress])
  @@index([blockNumber])
  @@index([timestamp])
  @@index([status])
  @@index([type])
  @@map("transaction_history")
}

model TokenTransfer {
  id                    String   @id @default(cuid())
  transactionHistoryId  String
  tokenAddress          String
  tokenSymbol           String
  tokenName             String
  fromAddress           String
  toAddress             String
  value                 String
  decimals              Int
  
  // Relations
  transactionHistory    TransactionHistory @relation(fields: [transactionHistoryId], references: [id], onDelete: Cascade)
  
  @@index([transactionHistoryId])
  @@index([tokenAddress])
  @@index([fromAddress])
  @@index([toAddress])
  @@map("token_transfers")
}

model BankAccount {
  id              String   @id @default(cuid())
  userId          String
  plaidAccountId  String?  @unique
  accountName     String
  accountType     AccountType
  bankName        String
  accountNumber   String   // Encrypted
  routingNumber   String?  // Encrypted
  isActive        Boolean  @default(true)
  isVerified      Boolean  @default(false)
  balance         Float?
  currency        String   @default("USD")
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  // Relations
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId, isActive])
  @@index([userId, isVerified])
  @@index([bankName])
  @@index([accountType])
  @@map("bank_accounts")
}

model SavingsTransaction {
  id                String   @id @default(cuid())
  userId            String
  type              TransactionType
  amount            Float
  currency          String   @default("USD")
  blockchainTxHash  String?  @unique
  status            TransactionStatus @default(PENDING)
  createdAt         DateTime @default(now())
  
  // Round-up specific
  originalTransactionAmount Float?
  merchant          String?
  category          String?
  
  // Yield specific
  yieldProtocol     String?
  apy               Float?
  
  // Relations
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId, createdAt])
  @@index([userId, type])
  @@index([userId, status])
  @@index([status, createdAt])
  @@index([blockchainTxHash])
  @@index([merchant])
  @@index([category])
  @@map("savings_transactions")
}

model Achievement {
  id                String   @id @default(cuid())
  name              String   @unique
  description       String
  icon              String
  category          AchievementCategory
  rarity            AchievementRarity
  pointsReward      Int
  createdAt         DateTime @default(now())
  
  // Relations
  userAchievements  UserAchievement[]
  
  @@map("achievements")
}

model UserAchievement {
  id            String   @id @default(cuid())
  userId        String
  achievementId String
  unlockedAt    DateTime @default(now())
  
  // Relations
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  achievement   Achievement @relation(fields: [achievementId], references: [id], onDelete: Cascade)
  
  @@unique([userId, achievementId])
  @@map("user_achievements")
}

model Challenge {
  id            String   @id @default(cuid())
  creatorId     String
  title         String
  description   String
  type          ChallengeType
  targetAmount  Float?
  duration      Int      // in days
  startDate     DateTime
  endDate       DateTime
  status        ChallengeStatus @default(ACTIVE)
  createdAt     DateTime @default(now())
  
  // Relations
  creator       User     @relation("ChallengeCreator", fields: [creatorId], references: [id], onDelete: Cascade)
  participants  ChallengeParticipant[]
  
  @@index([status, endDate])
  @@index([creatorId])
  @@index([type])
  @@index([createdAt])
  @@map("challenges")
}

model ChallengeParticipant {
  id              String   @id @default(cuid())
  userId          String
  challengeId     String
  joinedAt        DateTime @default(now())
  currentProgress Float    @default(0)
  rank            Int?
  
  // Relations
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  challenge       Challenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)
  
  @@unique([userId, challengeId])
  @@map("challenge_participants")
}

model Friendship {
  id          String   @id @default(cuid())
  userId      String
  friendId    String
  status      FriendshipStatus @default(PENDING)
  createdAt   DateTime @default(now())
  acceptedAt  DateTime?
  
  // Relations
  user        User     @relation("UserFriendships", fields: [userId], references: [id], onDelete: Cascade)
  friend      User     @relation("FriendOf", fields: [friendId], references: [id], onDelete: Cascade)
  
  @@unique([userId, friendId])
  @@index([userId, status])
  @@index([friendId, status])
  @@index([status, createdAt])
  @@map("friendships")
}

model Notification {
  id          String   @id @default(cuid())
  userId      String
  type        NotificationType
  title       String
  message     String
  data        Json?
  read        Boolean  @default(false)
  createdAt   DateTime @default(now())
  
  // Relations
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId, read])
  @@index([userId, createdAt])
  @@index([type])
  @@index([createdAt])
  @@map("notifications")
}

// Enums
enum RiskTolerance {
  LOW
  MEDIUM
  HIGH
}

enum WalletProvider {
  METAMASK
  WALLETCONNECT
  COINBASE
  RAINBOW
  TRUST
}

enum PrivacyLevel {
  PUBLIC
  FRIENDS
  PRIVATE
}

enum AccountType {
  CHECKING
  SAVINGS
  CREDIT
  INVESTMENT
}

enum TransactionType {
  ROUNDUP
  MANUAL
  YIELD
  WITHDRAWAL
  DEPOSIT
  TRANSFER
}

enum TransactionStatus {
  PENDING
  CONFIRMED
  FAILED
  CANCELLED
}

enum AchievementCategory {
  SAVINGS
  SOCIAL
  STREAK
  SPECIAL
}

enum AchievementRarity {
  COMMON
  RARE
  EPIC
  LEGENDARY
}

enum ChallengeType {
  SAVINGS_AMOUNT
  STREAK
  SOCIAL
}

enum ChallengeStatus {
  ACTIVE
  COMPLETED
  CANCELLED
}

enum FriendshipStatus {
  PENDING
  ACCEPTED
  BLOCKED
}

enum NotificationType {
  ACHIEVEMENT
  CHALLENGE
  SAVINGS
  SOCIAL
  SYSTEM
  SECURITY
}

enum SessionType {
  GENERAL
  WALLET_SESSION
  API_TOKEN
}